<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>mousebrains v3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* ==================================================
       mousebrains v3
       Version History / Changelog:
       v1 - Initial maze grid generator
       v2 - Added start/exit points + mouse character with controls
       v3 - Mouse can exit maze; victory screen with animation + continue button
       ================================================== */

    :root {
      --bg: #0b0f14;
      --ink: #e8edf2;
      --grid: #2a3440;
      --walls: #cdd7e1;
      --accent: #76a9ff;
      --start: #28c76f;
      --exit: #ff7a90;
      --mouse: #c9d1d9; /* grey mouse (lighter for contrast) */
      --mouse-stroke: #4a5568;
      --mouse-accent: #ff7a90; /* ears, tail, nose */
      --eye-blue: #76a9ff;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0b0f14; color: var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .wrap { display: grid; place-items: center; min-height: 100%; padding: 24px; gap: 12px; }
    h1 { margin: 0; font-weight: 800; letter-spacing: .04em; text-transform: lowercase; font-size: clamp(18px,2.2vw,26px); opacity: .95; }
    .toolbar { display:flex; gap:12px; flex-wrap:wrap; justify-content:center; align-items:center; }
    .btn, .select {
      background:#141b24; color:var(--ink); border-radius:12px; border:1px solid #253041;
      padding:10px 14px; font-weight:600; appearance:none;
    }
    .btn { cursor:pointer; }
    .btn:hover { border-color: var(--accent); }
    canvas {
      width: min(92vmin, 900px);
      height: min(92vmin, 900px);
      display:block; border-radius:16px;
      box-shadow: 0 12px 40px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.03);
      background: linear-gradient(180deg, #0e1620 0%, #0b0f14 100%);
    }
    .note { opacity:.65; font-size:12px; }

    /* Victory overlay */
    #victoryScreen {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      z-index: 100;
      text-align: center;
    }
    #victoryScreen h2 {
      font-size: 2rem;
      margin-bottom: 20px;
    }
    #victoryScreen .big-mouse {
      font-size: 5rem;
      margin: 20px;
    }
    #victoryScreen p {
      font-size: 1.2rem;
      margin: 10px 0;
    }
    #victoryScreen button {
      background: var(--accent);
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>mousebrains</h1>
    <div class="toolbar">
      <label><span class="note">Grid:&nbsp;</span>
        <select id="gridSize" class="select">
          <option>15</option><option selected>21</option><option>31</option><option>41</option><option>51</option>
        </select>
      </label>
      <button id="regen" class="btn">Regenerate</button>
      <span class="note">Arrow Keys / WASD to move</span>
    </div>
    <canvas id="stage" width="900" height="900" aria-label="maze canvas"></canvas>
  </div>

  <!-- Victory Screen Overlay -->
  <div id="victoryScreen">
    <h2>You solved the maze!</h2>
    <div class="big-mouse">üê≠üß†</div>
    <p>Your brain grew bigger!</p>
    <p class="evil">An evil scientist appears... "You think you're pretty smart, huh, mouse? Wait until you see my next maze!"</p>
    <button id="continueBtn">Continue</button>
  </div>

  <script>
    /*
      mousebrains ‚Äî v0.3.3 (v3.3)
      Changelog:
      - v1: Foundation ‚Äì square grid, perfect maze gen, render walls.
      - v2: Start & farthest Exit; movable mouse avatar (WASD/Arrows).
      - v3: Allow stepping OUT through the exit. Win sequence split into
            Brain Pops ‚Üí Scientist Screen; Continue regenerates harder maze.
    */
    const VERSION = '0.3.3';

    // ===== Canvas & DPI =====
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    const gridSelect = document.getElementById('gridSize');
    const regenBtn = document.getElementById('regen');

    let gameState = 'play'; // 'play' | 'win'
    let winAnim = { t: 0, phase: 'brain', pops: 0 };
    const ui = { continueBtn: { x:0, y:0, w:0, h:0 } };

    function fitCanvasToCSS() {
      const cssSize = Math.min(window.innerWidth, window.innerHeight) * 0.92;
      const target = Math.min(cssSize, 900);
      const dpr = window.devicePixelRatio || 1;
      canvas.style.width = `${target}px`;
      canvas.style.height = `${target}px`;
      canvas.width = Math.floor(target * dpr);
      canvas.height = Math.floor(target * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', () => { fitCanvasToCSS(); draw(); });

    // ===== PRNG =====
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    // ===== Maze =====
    // cells[y][x] has walls t/r/b/l and visited v
    class Maze {
      constructor(n, rng = Math.random) {
        this.n = n % 2 === 0 ? n + 1 : n; // ensure odd
        this.rng = rng;
        this.cells = Array.from({ length: this.n }, () =>
          Array.from({ length: this.n }, () => ({ t: true, r: true, b: true, l: true, v: false }))
        );
        this.start = { x: 1, y: 1 }; // interior
        this.exit = null;             // boundary-adjacent interior cell
        this.exitSide = null;         // 't'|'r'|'b'|'l' (which outer wall is opened)
        this.generate();
      }
      inBounds(x, y){ return x>=0 && y>=0 && x<this.n && y<this.n; }
      neighbors(x,y){
        return [
          [x, y-1, 't','b'],
          [x+1, y, 'r','l'],
          [x, y+1, 'b','t'],
          [x-1,y, 'l','r'],
        ].filter(([nx,ny]) => this.inBounds(nx,ny));
      }
      shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(this.rng()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

      generate(){
        // DFS carve a perfect maze
        const st = this.start;
        const stack=[st];
        this.cells[st.y][st.x].v = true;
        while(stack.length){
          const cur=stack[stack.length-1];
          const order=this.shuffle(this.neighbors(cur.x,cur.y));
          const next=order.find(([nx,ny]) => !this.cells[ny][nx].v);
          if(next){
            const [nx,ny,dFrom,dTo]=next;
            this.cells[cur.y][cur.x][dFrom]=false;
            this.cells[ny][nx][dTo]=false;
            this.cells[ny][nx].v=true;
            stack.push({x:nx,y:ny});
          } else stack.pop();
        }
        // Keep strong outer boundary
        for(let i=0;i<this.n;i++){
          this.cells[0][i].t=true;
          this.cells[this.n-1][i].b=true;
          this.cells[i][0].l=true;
          this.cells[i][this.n-1].r=true;
        }
        // Choose EXIT as farthest boundary-adjacent interior cell; open its outer wall
        const dist = this.distanceFrom(this.start);
        let best = { d:-1, x:this.start.x, y:this.start.y, side:'r' };
        for(let y=1;y<this.n-1;y++){
          if(dist[y][1] > best.d){ best={d:dist[y][1], x:1, y, side:'l'}; }
          if(dist[y][this.n-2] > best.d){ best={d:dist[y][this.n-2], x:this.n-2, y, side:'r'}; }
        }
        for(let x=1;x<this.n-1;x++){
          if(dist[1][x] > best.d){ best={d:dist[1][x], x, y:1, side:'t'}; }
          if(dist[this.n-2][x] > best.d){ best={d:dist[this.n-2][x], x, y:this.n-2, side:'b'}; }
        }
        this.exit = { x: best.x, y: best.y };
        this.exitSide = best.side;
        // Open entrance at start (to outside) on the left by default// Open exit to outside (gap on the border when rendering)
        this.cells[this.exit.y][this.exit.x][this.exitSide] = false;
      }

      distanceFrom(s) {
        const INF = 1e9;
        const d = Array.from({length:this.n},()=>Array(this.n).fill(INF));
        const q = [{x:s.x,y:s.y}];
        d[s.y][s.x]=0; let qi=0;
        while(qi<q.length){
          const {x,y} = q[qi++];
          const here = this.cells[y][x];
          const dirs = [
            [x, y-1, !here.t],
            [x+1, y, !here.r],
            [x, y+1, !here.b],
            [x-1, y, !here.l],
          ];
          for(const [nx,ny,open] of dirs){
            if(!open || !this.inBounds(nx,ny)) continue;
            if(d[ny][nx] > d[y][x]+1){ d[ny][nx]=d[y][x]+1; q.push({x:nx,y:ny}); }
          }
        }
        return d;
      }
    }

    // ===== Drawing =====
    function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

    function drawGrid(n, cell) {
      const { width, height } = canvas.getBoundingClientRect();
      ctx.lineWidth = 1; ctx.strokeStyle = cssVar('--grid');
      ctx.beginPath();
      for(let i=0;i<=n;i++){
        const p = Math.round(i*cell)+.5;
        ctx.moveTo(.5, p); ctx.lineTo(width-.5, p);
        ctx.moveTo(p, .5); ctx.lineTo(p, height-.5);
      }
      ctx.stroke();
    }

    function drawOuterBoundaryWithGaps(n, cell, maze) {
      const w = Math.max(4, Math.floor(cell*.2));
      const { width, height } = canvas.getBoundingClientRect();
      ctx.lineWidth = w; ctx.strokeStyle = cssVar('--walls');
      ctx.beginPath();
      // Top
      const gapTop = (maze.exitSide==='t') ? maze.exit.x : -1;
      drawSideWithGap('top', gapTop);
      // Right
      const gapRight = (maze.exitSide==='r') ? maze.exit.y : -1;
      drawSideWithGap('right', gapRight);
      // Bottom
      const gapBottom = (maze.exitSide==='b') ? maze.exit.x : -1;
      drawSideWithGap('bottom', gapBottom);
      // Left (also entrance at start left)
      const gapLeft = (maze.exitSide==='l') ? maze.exit.y : -1;
      drawSideWithGap('left', gapLeft);
      ctx.stroke();

      function drawSideWithGap(side, gapIndex){
        const half = w/2;
        if(side==='top'){
          const y = half;
          if(gapIndex<0){ ctx.moveTo(half,y); ctx.lineTo(width-half,y); }
          else {
            const xg0 = gapIndex*cell, xg1=(gapIndex+1)*cell;
            ctx.moveTo(half,y); ctx.lineTo(xg0,y);
            ctx.moveTo(xg1,y); ctx.lineTo(width-half,y);
          }
        } else if(side==='bottom'){
          const y = height-half;
          if(gapIndex<0){ ctx.moveTo(half,y); ctx.lineTo(width-half,y); }
          else {
            const xg0 = gapIndex*cell, xg1=(gapIndex+1)*cell;
            ctx.moveTo(half,y); ctx.lineTo(xg0,y);
            ctx.moveTo(xg1,y); ctx.lineTo(width-half,y);
          }
        } else if(side==='left'){
          const x = half;
          if(gapIndex<0){ ctx.moveTo(x,half); ctx.lineTo(x,height-half); }
          else {
            const yg0 = gapIndex*cell, yg1=(gapIndex+1)*cell;
            ctx.moveTo(x,half); ctx.lineTo(x,yg0);
            ctx.moveTo(x,yg1); ctx.lineTo(x,height-half);
          }
        } else if(side==='right'){
          const x = width-half;
          if(gapIndex<0){ ctx.moveTo(x,half); ctx.lineTo(x,height-half); }
          else {
            const yg0 = gapIndex*cell, yg1=(gapIndex+1)*cell;
            ctx.moveTo(x,half); ctx.lineTo(x,yg0);
            ctx.moveTo(x,yg1); ctx.lineTo(x,height-half);
          }
        }
      }
    }

    function drawMaze(maze) {
      const { width, height } = canvas.getBoundingClientRect();
      const n = maze.n; const cell = width / n;
      ctx.clearRect(0,0,width,height);
      drawGrid(n, cell);
      ctx.strokeStyle = cssVar('--walls');
      ctx.lineWidth = Math.max(2, Math.floor(cell * 0.14));
      ctx.lineCap = 'square';
      ctx.beginPath();
      for(let y=0;y<n;y++){
        for(let x=0;x<n;x++){
          const c = maze.cells[y][x];
          const x0 = x*cell, y0=y*cell, x1=x0+cell, y1=y0+cell;
          if(c.t){ ctx.moveTo(x0,y0); ctx.lineTo(x1,y0); }
          if(c.r){ ctx.moveTo(x1,y0); ctx.lineTo(x1,y1); }
          if(c.b){ ctx.moveTo(x0,y1); ctx.lineTo(x1,y1); }
          if(c.l){ ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); }
        }
      }
      ctx.stroke();

      // START tile
      const s = maze.start;
      ctx.fillStyle = cssVar('--start');
      ctx.globalAlpha = 0.18; ctx.fillRect(s.x*cell, s.y*cell, cell, cell); ctx.globalAlpha = 1;

      // EXIT glow marker inside the exit cell
      const e = maze.exit; const cx = (e.x+0.5)*cell, cy=(e.y+0.5)*cell; const r = cell*0.28;
      const grad = ctx.createRadialGradient(cx,cy,0,cx,cy,r*2.2);
      grad.addColorStop(0, cssVar('--exit')); grad.addColorStop(1, 'rgba(255,122,144,0)');
      ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx,cy,r*2,0,Math.PI*2); ctx.fill();

      // Outer boundary with entrance/exit gaps drawn last
      drawOuterBoundaryWithGaps(n, cell, maze);
    }

    // ===== Player (Mouse) =====
    const Keys = { ArrowUp:false, ArrowRight:false, ArrowDown:false, ArrowLeft:false, KeyW:false, KeyA:false, KeyS:false, KeyD:false };
    addEventListener('keydown', e=>{ if(Keys.hasOwnProperty(e.code)){ Keys[e.code]=true; e.preventDefault(); }});
    addEventListener('keyup',   e=>{ if(Keys.hasOwnProperty(e.code)){ Keys[e.code]=false; e.preventDefault(); }});

    const player = {
      x: 1, y: 1,          // cell coordinates (integer when resting)
      px: 1, py: 1,        // precise (float) during animation
      dir: {x:1, y:0},     // facing direction
      moving: false,
      from: {x:1,y:1},
      to: {x:1,y:1},
      t: 0,                // 0..1 progress
      speed: 6,            // cells per second
    };

    function canMove(maze, x, y, dx, dy){
      // Allow stepping OUT only if at the exit cell and moving outward through its open side.
      const atExit = (x === maze.exit.x && y === maze.exit.y);
      if(atExit){
        if(maze.exitSide==='r' && dx===1) return true;
        if(maze.exitSide==='l' && dx===-1) return true;
        if(maze.exitSide==='b' && dy===1) return true;
        if(maze.exitSide==='t' && dy===-1) return true;
      }
      const c = maze.cells[y][x];
      if(dx===1)  return !c.r;
      if(dx===-1) return !c.l;
      if(dy===1)  return !c.b;
      if(dy===-1) return !c.t;
      return false;
    }

    function updatePlayer(dt, maze){
      if(gameState==='win') return; // freeze during win
      // If at rest, read input for a new step
      if(!player.moving){
        let dx=0, dy=0;
        if(Keys.ArrowUp||Keys.KeyW) dy=-1;
        else if(Keys.ArrowDown||Keys.KeyS) dy=1;
        else if(Keys.ArrowLeft||Keys.KeyA) dx=-1;
        else if(Keys.ArrowRight||Keys.KeyD) dx=1;

        if(dx||dy){
          if(canMove(maze, player.x, player.y, dx, dy)){
            player.moving = true;
            player.from = {x: player.x, y: player.y};
            // Default one-cell step
            let tx = player.x + dx;
            let ty = player.y + dy;
            // If at the exit cell and moving outward, jump directly OUTSIDE
            const atExit = (player.x === maze.exit.x && player.y === maze.exit.y);
            if(atExit){
              if(maze.exitSide==='r' && dx===1){ tx = maze.n; ty = player.y; }
              if(maze.exitSide==='l' && dx===-1){ tx = -1; ty = player.y; }
              if(maze.exitSide==='b' && dy===1){ ty = maze.n; tx = player.x; }
              if(maze.exitSide==='t' && dy===-1){ ty = -1; tx = player.x; }
            }
            player.to   = {x: tx, y: ty};
            player.t = 0; player.dir = {x:dx, y:dy};
          } else {
            player.dir = {x:dx, y:dy}; // turn but don't move
          }
        }
      }

      if(player.moving){
        const stepDuration = 1 / player.speed; // seconds per cell
        player.t += dt / stepDuration;
        if(player.t >= 1){
          player.t = 1;
          player.moving=false;
          player.x = player.to.x;
          player.y = player.to.y;
          player.px = player.x; player.py = player.y;
          // If we've moved outside the maze bounds from the exit, trigger win
          if(player.x < 0 || player.y < 0 || player.x >= maze.n || player.y >= maze.n){
            triggerWin();
          }
        } else {
          player.px = player.from.x + (player.to.x - player.from.x)*player.t;
          player.py = player.from.y + (player.to.y - player.from.y)*player.t;
        }
      } else {
        player.px = player.x; player.py = player.y;
      }
    }

    function drawMouse(cell){
      const cx = (player.px + 0.5)*cell;
      const cy = (player.py + 0.5)*cell;
      const radius = cell*0.32;
      const ang = Math.atan2(player.dir.y, player.dir.x);
      const mouthOpen = 0.35 + 0.10*Math.sin(performance.now()*0.004);
      const a0 = ang - mouthOpen;
      const a1 = ang + mouthOpen;
      // Tail
      ctx.lineWidth = Math.max(2, Math.floor(cell*0.08));
      ctx.strokeStyle = cssVar('--mouse-accent');
      const tailLen = radius*1.4;
      const tailAng = ang + Math.PI + 0.25*Math.sin(performance.now()*0.006);
      ctx.beginPath();
      ctx.moveTo(cx - Math.cos(ang)*radius*0.8, cy - Math.sin(ang)*radius*0.8);
      ctx.lineTo(cx + Math.cos(tailAng)*tailLen, cy + Math.sin(tailAng)*tailLen);
      ctx.stroke();
      // Halo for readability on dark maze
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = '#e8edf2';
      ctx.lineWidth = Math.max(1, Math.floor(cell*0.12));
      ctx.beginPath(); ctx.arc(cx, cy, radius*1.05, 0, Math.PI*2); ctx.stroke();
      ctx.restore();

      // Body (Pac wedge)
      ctx.fillStyle = cssVar('--mouse');
      ctx.strokeStyle = cssVar('--mouse-stroke');
      ctx.lineWidth = Math.max(1.5, Math.floor(cell*0.05));
      ctx.beginPath(); ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, radius, a0, a1, false);
      ctx.closePath(); ctx.fill(); ctx.stroke();
      // Ears
      const earOffset = radius*0.75, earR = radius*0.32;
      const earAngle1 = ang - Math.PI/2, earAngle2 = ang + Math.PI/2;
      const ex1 = cx + Math.cos(earAngle1)*earOffset;
      const ey1 = cy + Math.sin(earAngle1)*earOffset;
      const ex2 = cx + Math.cos(earAngle2)*earOffset;
      const ey2 = cy + Math.sin(earAngle2)*earOffset;
      ctx.fillStyle = cssVar('--mouse-accent');
      ctx.beginPath(); ctx.arc(ex1,ey1,earR,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.arc(ex2,ey2,earR,0,Math.PI*2); ctx.fill(); ctx.stroke();
      // Eye
      const eyeR = radius*0.12;
      const ex = cx + Math.cos(ang)*radius*0.25 + Math.cos(ang - Math.PI/2)*radius*0.15;
      const ey = cy + Math.sin(ang)*radius*0.25 + Math.sin(ang - Math.PI/2)*radius*0.15;
      ctx.fillStyle = cssVar('--eye-blue');
      ctx.beginPath(); ctx.arc(ex,ey,eyeR,0,Math.PI*2); ctx.fill();
      // Nose (tip)
      const nx = cx + Math.cos(ang) * radius * 0.98;
      const ny = cy + Math.sin(ang) * radius * 0.98;
      ctx.fillStyle = cssVar('--mouse-accent');
      ctx.beginPath(); ctx.arc(nx, ny, radius*0.10, 0, Math.PI*2); ctx.fill();
    }

    // ===== Game state / loop =====
    let rng = mulberry32(Math.floor(Math.random()*1e9));
    let maze = null; let lastTime = 0;

    function bumpDifficulty(){
      const sizes = [15,21,31,41,51];
      const cur = parseInt(gridSelect.value, 10);
      const idx = Math.max(0, sizes.indexOf(cur));
      const next = sizes[Math.min(idx+1, sizes.length-1)];
      gridSelect.value = String(next);
    }

    function regenerate(){
      const n = parseInt(gridSelect.value, 10);
      maze = new Maze(n, rng);
      // Reset player at start
      player.x = player.px = maze.start.x;
      player.y = player.py = maze.start.y;
      player.moving = false;
      player.dir = {x:1,y:0};
      gameState = 'play';
      
      draw();
    }

    function draw(){
      fitCanvasToCSS();
      if(!maze) return;
      const { width, height } = canvas.getBoundingClientRect();
      if(gameState==='win'){
        if(winAnim.phase==='brain') { drawWinScene(width, height); }
        else { drawScientistScene(width, height); }
        return;
      }
      drawMaze(maze);
      // width already measured above
      const cell = width / maze.n;
      drawMouse(cell);
    }

    function triggerWin(){
      gameState='win';
      winAnim = { t: 0, phase: 'brain', pops: 0 };
    }

    function loop(ts){
      if(!lastTime) lastTime = ts;
      const dt = Math.min(0.05, (ts - lastTime)/1000);
      lastTime = ts;
      if(maze){
        updatePlayer(dt, maze);
        if(gameState==='win'){ winAnim.t += dt; }
        draw();
      }
      requestAnimationFrame(loop);
    }

    // UI
    regenBtn.addEventListener('click', () => { rng = mulberry32(Math.floor(Math.random()*1e9)); regenerate(); });
    gridSelect.addEventListener('change', regenerate);

    // Click for Continue on win scene (canvas UI)
    canvas.addEventListener('click', (e)=>{
      if(gameState!=='win') return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      const b = ui.continueBtn;
      if(x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h){
        bumpDifficulty();
        rng = mulberry32(Math.floor(Math.random()*1e9));
        regenerate();
      }
    });

    // Init
    fitCanvasToCSS();
    regenerate();
    requestAnimationFrame(loop);
  
    // ===== Win Scene Drawing (brain pops + pixel scientist) =====
    function drawWinScene(width, height){
      // Backdrop
      ctx.clearRect(0,0,width,height);
      ctx.fillStyle = '#0b0f14';
      ctx.fillRect(0,0,width,height);

      // Title
      ctx.fillStyle = '#e8edf2';
      ctx.textAlign = 'center';
      ctx.font = `800 ${Math.max(22, Math.floor(width*0.06))}px system-ui, sans-serif`;
      ctx.fillText('You solved the maze!', width/2, height*0.18);

      // Brain pop sequence (mouse on screen, brain does 3 jump-ups)
      const POPS = 3;           // number of brain pops
      const POP_DUR = 0.35;     // seconds per pop
      const totalPopTime = POPS*POP_DUR;
      const t = Math.min(winAnim.t, totalPopTime);
      const popIndex = Math.min(Math.floor(t / POP_DUR), POPS-1);
      const local = (t - popIndex*POP_DUR) / POP_DUR; // 0..1 within current pop
      // triangle pulse 0..1..0
      const pulse = 1 - Math.abs(1 - 2*local);
      const baseBoost = 1 + 0.12 * popIndex; // each pop leaves it a bit larger
      const brainScale = baseBoost * (1 + 0.75 * pulse); // bigger pop + trending growth

      const cx = width/2, cy = height*0.5;
      const baseR = Math.min(width,height)*0.12;
      drawBigMouse(cx, cy, baseR, 1.0, brainScale);

      if(winAnim.t >= totalPopTime){
        // advance to scientist screen
        winAnim.phase = 'scientist';
        winAnim.t = 0;
      }
    
    }

    function drawBigMouse(cx, cy, baseR, bodyScale, brainScale){
      const r = baseR * bodyScale;
      const mouthOpen = 0.25;

      // Tail (little idle wiggle)
      ctx.lineWidth = Math.max(2, Math.floor(baseR*0.18));
      ctx.strokeStyle = cssVar('--mouse-accent');
      const tailLen = baseR*1.6;
      ctx.beginPath();
      ctx.moveTo(cx - baseR*0.8, cy);
      ctx.lineTo(cx - baseR*0.8 - tailLen, cy + Math.sin(performance.now()*0.006)*baseR*0.15);
      ctx.stroke();

      // Body (Pac wedge)
      ctx.fillStyle = cssVar('--mouse');
      ctx.strokeStyle = cssVar('--mouse-stroke');
      ctx.lineWidth = Math.max(1.5, Math.floor(baseR*0.06));
      ctx.beginPath(); ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, r, -mouthOpen, mouthOpen, false);
      ctx.closePath(); ctx.fill(); ctx.stroke();

      // Ears
      const earOffset = r*0.75, earR = r*0.32;
      ctx.fillStyle = cssVar('--mouse-accent');
      ctx.beginPath(); ctx.arc(cx, cy-earOffset, earR, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.arc(cx, cy+earOffset, earR, 0, Math.PI*2); ctx.fill(); ctx.stroke();

      // Eye
      ctx.fillStyle = cssVar('--eye-blue');
      ctx.beginPath(); ctx.arc(cx+r*0.25, cy-r*0.05, r*0.12, 0, Math.PI*2); ctx.fill();
      // Nose on snout
      ctx.fillStyle = cssVar('--mouse-accent');
      ctx.beginPath(); ctx.arc(cx + r*0.98, cy - r*0.02, r*0.10, 0, Math.PI*2); ctx.fill();

      // Brain: two lobes + midline with gyri squiggles, scaled by brainScale
      const bx = cx + r*0.25;
      const by = cy - r*0.55;
      const bR = Math.max(2, r*0.28) * brainScale; // main size driver
      const lobeR = bR*0.85;

      // Main lobes
      ctx.fillStyle = '#ff7a90';
      ctx.strokeStyle = '#c84864';
      ctx.lineWidth = Math.max(1, Math.floor(bR*0.12));
      // Left lobe
      ctx.beginPath(); ctx.arc(bx - bR*0.35, by, lobeR, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      // Right lobe
      ctx.beginPath(); ctx.arc(bx + bR*0.35, by, lobeR, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      // Overlap cap (center bump)
      ctx.beginPath(); ctx.arc(bx, by - bR*0.15, lobeR*0.9, 0, Math.PI*2); ctx.fill();

      // Midline
      ctx.strokeStyle = '#8a2e45'; ctx.lineWidth = Math.max(1, Math.floor(bR*0.08));
      ctx.beginPath(); ctx.moveTo(bx, by - bR*0.8); ctx.lineTo(bx, by + bR*0.8); ctx.stroke();

      // Gyri (squiggles)
      ctx.strokeStyle = '#d65b79'; ctx.lineWidth = Math.max(1, Math.floor(bR*0.06));
      for(let i=0;i<5;i++){
        const yy = by - bR*0.6 + i*(bR*0.3);
        const amp = bR*0.18*(i%2?1:0.7);
        ctx.beginPath();
        ctx.moveTo(bx - bR*0.7, yy);
        for(let k=0;k<=6;k++){
          const t = k/6;
          const x = bx - bR*0.7 + t*(bR*1.4);
          const y = yy + Math.sin((t+ i*0.2)*Math.PI*2)*amp;
          ctx.lineTo(x,y);
        }
        ctx.stroke();
      }
    }

    function drawScientistScene(width, height){
      // Fresh screen
      ctx.clearRect(0,0,width,height);
      ctx.fillStyle = '#0b0f14'; ctx.fillRect(0,0,width,height);

      // Layout: left text panel for readability
      const panelX = width*0.08, panelW = width*0.46, panelY = height*0.18, panelH = height*0.28;
      ctx.fillStyle = 'rgba(20,27,36,0.75)';
      if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(panelX, panelY, panelW, panelH, 14); ctx.fill(); }
      else { ctx.fillRect(panelX, panelY, panelW, panelH); }
      ctx.fillStyle = '#e8edf2';
      ctx.textAlign = 'left';
      ctx.font = `800 ${Math.max(20, Math.floor(width*0.05))}px system-ui, sans-serif`;
      ctx.fillText('Very clever, mouse!', panelX + 18, panelY + panelH*0.45);
      ctx.font = `700 ${Math.max(14, Math.floor(width*0.03))}px system-ui, sans-serif`;
      ctx.fillText("I bet you can't solve my next maze!", panelX + 18, panelY + panelH*0.75);

      // Fade-in scientist on the right; grin after 60% of fade
      const SCI_FADE = 0.8;
      const f = Math.max(0, Math.min(1, winAnim.t/SCI_FADE));
      drawScientistPixelFull(width, height, f>=0.6, f);

      // Continue button appears slightly after fully visible
      const showBtn = winAnim.t > (SCI_FADE + 0.3);
      if(showBtn){
        const btnW = Math.max(160, Math.floor(width*0.28));
        const btnH = Math.max(44, Math.floor(height*0.07));
        const btnX = width/2 - btnW/2; const btnY = height*0.82 - btnH/2;
        ui.continueBtn = { x: btnX, y: btnY, w: btnW, h: btnH };
        ctx.fillStyle = '#141b24'; ctx.strokeStyle = '#76a9ff'; ctx.lineWidth = 2;
        if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(btnX, btnY, btnW, btnH, 12); ctx.fill(); ctx.stroke(); }
        else { ctx.fillRect(btnX, btnY, btnW, btnH); ctx.strokeRect(btnX, btnY, btnW, btnH); }
        ctx.fillStyle = '#e8edf2'; ctx.font = `700 ${Math.max(14, Math.floor(width*0.035))}px system-ui, sans-serif`;
        ctx.fillText('Continue', width/2, btnY + btnH*0.66);
      } else {
        ui.continueBtn = { x:0,y:0,w:0,h:0 };
      }
    }

    function drawScientistPixelFull(width, height, grin, alpha){
      // Pixel-art full figure: head, coat, legs, black shoes
      const unit = Math.floor(Math.min(width, height) * 0.018); // pixel size
      const ox = Math.floor(width*0.72); // place on right for clear layout
      const oy = Math.floor(height*0.60);
      ctx.save(); ctx.globalAlpha = alpha; // fade-in

      const colors = {
        O:'#202632', W:'#e8edf2', S:'#e8c7a8', H:'#cfd6e2', M:'#ff7a90', B:'#111823'
      };

      // Body (coat)
      const coatW = 18*unit, coatH = 22*unit;
      ctx.fillStyle = colors.W;
      ctx.fillRect(ox - coatW/2, oy - coatH/2, coatW, coatH);
      ctx.strokeStyle = colors.O; ctx.lineWidth = Math.max(1, Math.floor(unit*0.25));
      ctx.strokeRect(ox - coatW/2, oy - coatH/2, coatW, coatH);
      // Lapels (simple V)
      ctx.beginPath(); ctx.moveTo(ox, oy - coatH/2); ctx.lineTo(ox - coatW*0.18, oy - coatH*0.1); ctx.lineTo(ox, oy + coatH*0.05); ctx.lineTo(ox + coatW*0.18, oy - coatH*0.1); ctx.closePath(); ctx.stroke();
      // Buttons
      for(let i=0;i<3;i++){ ctx.beginPath(); ctx.arc(ox, oy - coatH*0.2 + i*coatH*0.18, unit*0.6, 0, Math.PI*2); ctx.fillStyle = colors.O; ctx.fill(); }

      // Legs
      const legW = 5*unit, legH = 10*unit;
      ctx.fillStyle = '#2a2f3a';
      ctx.fillRect(ox - legW - unit, oy + coatH/2 - unit, legW, legH);
      ctx.fillRect(ox + unit, oy + coatH/2 - unit, legW, legH);

      // Shoes (black)
      const shoeW = 6*unit, shoeH = 2.5*unit;
      ctx.fillStyle = colors.B;
      ctx.fillRect(ox - legW - unit, oy + coatH/2 + legH - unit, shoeW, shoeH);
      ctx.fillRect(ox + unit, oy + coatH/2 + legH - unit, shoeW, shoeH);
      ctx.strokeStyle = colors.O; ctx.strokeRect(ox - legW - unit, oy + coatH/2 + legH - unit, shoeW, shoeH);
      ctx.strokeRect(ox + unit, oy + coatH/2 + legH - unit, shoeW, shoeH);

      // Head + hair (pixel grid 16x16) on top of coat
      const headScale = unit; const hx = ox, hy = oy - coatH/2 - 6*unit;
      const neutral = [
        "     HHHHHH     ",
        "    HHHHHHHH    ",
        "   HHHHHHHHHH   ",
        "   HSSSSSSSSH   ",
        "  HSSSSSSSSSSH  ",
        "  HSSWSSSSWSSH  ",
        "  HSS  SS  SSH  ",
        "  HSS  SS  SSH  ",
        "  HSSS    SSSH  ",
        "   HSSSSSSSSH   ",
        "    OOOOOOOO    ",
        "    OWWWWWWO    ",
        "    O W  W O    ",
        "    O  WWW  O   ",
        "      OOOO      ",
        "                ",
      ];
      const grinRows = [
        "     HHHHHH     ",
        "    HHHHHHHH    ",
        "   HHHHHHHHHH   ",
        "   HSSSSSSSSH   ",
        "  HSSSSSSSSSSH  ",
        "  HSSWSSSSWSSH  ",
        "  HSS  SS  SSH  ",
        "  HSS  SS  SSH  ",
        "  HSSS    SSSH  ",
        "   HSSSSSSSSH   ",
        "    OOOOOOOO    ",
        "    OWWWWWWO    ",
        "    O W  W O    ",
        "    O MMMMM O   ",
        "      OOOO      ",
        "                ",
      ];
      const sprite = grin ? grinRows : neutral;
      for(let y=0;y<16;y++){
        for(let x=0;x<16;x++){
          const ch = sprite[y][x];
          const col = colors[ch];
          if(!col) continue;
          ctx.fillStyle = col;
          ctx.fillRect(hx + (x-8)*headScale, hy + (y-8)*headScale, headScale, headScale);
        }
      }

      ctx.restore();
    }
  </script>
</body>
</html>
